// automatically generated by the FlatBuffers compiler, do not modify

import * as flatbuffers from 'flatbuffers';

export class MosaicLevy {
    bb: flatbuffers.ByteBuffer | null = null;
    bb_pos = 0;
    __init(i: number, bb: flatbuffers.ByteBuffer): MosaicLevy {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
  
    static getRootAsMosaicLevy(bb: flatbuffers.ByteBuffer, obj?: MosaicLevy): MosaicLevy {
      return (obj || new MosaicLevy()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
  
    static getSizePrefixedRootAsMosaicLevy(bb: flatbuffers.ByteBuffer, obj?: MosaicLevy): MosaicLevy {
      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
      return (obj || new MosaicLevy()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
  
    type(): number {
      const offset = this.bb!.__offset(this.bb_pos, 4);
      return offset ? this.bb!.readUint8(this.bb_pos + offset) : 0;
    }
  
    recipient(index: number): number | null {
      const offset = this.bb!.__offset(this.bb_pos, 6);
      return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;
    }
  
    recipientLength(): number {
      const offset = this.bb!.__offset(this.bb_pos, 6);
      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
    }
  
    recipientArray(): Uint8Array | null {
      const offset = this.bb!.__offset(this.bb_pos, 6);
      return offset ? new Uint8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
    }
  
    mosaicId(index: number): number | null {
      const offset = this.bb!.__offset(this.bb_pos, 8);
      return offset ? this.bb!.readUint32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
    }
  
    mosaicIdLength(): number {
      const offset = this.bb!.__offset(this.bb_pos, 8);
      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
    }
  
    mosaicIdArray(): Uint32Array | null {
      const offset = this.bb!.__offset(this.bb_pos, 8);
      return offset ? new Uint32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
    }
  
    fee(index: number): number | null {
      const offset = this.bb!.__offset(this.bb_pos, 10);
      return offset ? this.bb!.readUint32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
    }
  
    feeLength(): number {
      const offset = this.bb!.__offset(this.bb_pos, 10);
      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
    }
  
    feeArray(): Uint32Array | null {
      const offset = this.bb!.__offset(this.bb_pos, 10);
      return offset ? new Uint32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
    }
  
    static startMosaicLevy(builder: flatbuffers.Builder) {
      builder.startObject(4);
    }
  
    static addType(builder: flatbuffers.Builder, type: number) {
      builder.addFieldInt8(0, type, 0);
    }
  
    static addRecipient(builder: flatbuffers.Builder, recipientOffset: flatbuffers.Offset) {
      builder.addFieldOffset(1, recipientOffset, 0);
    }
  
    static createRecipientVector(builder: flatbuffers.Builder, data: number[] | Uint8Array): flatbuffers.Offset {
      builder.startVector(1, data.length, 1);
      for (let i = data.length - 1; i >= 0; i--) {
        builder.addInt8(data[i]!);
      }
      return builder.endVector();
    }
  
    static startRecipientVector(builder: flatbuffers.Builder, numElems: number) {
      builder.startVector(1, numElems, 1);
    }
  
    static addMosaicId(builder: flatbuffers.Builder, mosaicIdOffset: flatbuffers.Offset) {
      builder.addFieldOffset(2, mosaicIdOffset, 0);
    }
  
    static createMosaicIdVector(builder: flatbuffers.Builder, data: number[] | Uint32Array): flatbuffers.Offset;
    /**
     * @deprecated This Uint8Array overload will be removed in the future.
     */
    static createMosaicIdVector(builder: flatbuffers.Builder, data: number[] | Uint8Array): flatbuffers.Offset;
    static createMosaicIdVector(builder: flatbuffers.Builder, data: number[] | Uint32Array | Uint8Array): flatbuffers.Offset {
      builder.startVector(4, data.length, 4);
      for (let i = data.length - 1; i >= 0; i--) {
        builder.addInt32(data[i]!);
      }
      return builder.endVector();
    }
  
    static startMosaicIdVector(builder: flatbuffers.Builder, numElems: number) {
      builder.startVector(4, numElems, 4);
    }
  
    static addFee(builder: flatbuffers.Builder, feeOffset: flatbuffers.Offset) {
      builder.addFieldOffset(3, feeOffset, 0);
    }
  
    static createFeeVector(builder: flatbuffers.Builder, data: number[] | Uint32Array): flatbuffers.Offset;
    /**
     * @deprecated This Uint8Array overload will be removed in the future.
     */
    static createFeeVector(builder: flatbuffers.Builder, data: number[] | Uint8Array): flatbuffers.Offset;
    static createFeeVector(builder: flatbuffers.Builder, data: number[] | Uint32Array | Uint8Array): flatbuffers.Offset {
      builder.startVector(4, data.length, 4);
      for (let i = data.length - 1; i >= 0; i--) {
        builder.addInt32(data[i]!);
      }
      return builder.endVector();
    }
  
    static startFeeVector(builder: flatbuffers.Builder, numElems: number) {
      builder.startVector(4, numElems, 4);
    }
  
    static endMosaicLevy(builder: flatbuffers.Builder): flatbuffers.Offset {
      const offset = builder.endObject();
      return offset;
    }
  
    static createMosaicLevy(builder: flatbuffers.Builder, type: number, recipientOffset: flatbuffers.Offset, mosaicIdOffset: flatbuffers.Offset, feeOffset: flatbuffers.Offset): flatbuffers.Offset {
      MosaicLevy.startMosaicLevy(builder);
      MosaicLevy.addType(builder, type);
      MosaicLevy.addRecipient(builder, recipientOffset);
      MosaicLevy.addMosaicId(builder, mosaicIdOffset);
      MosaicLevy.addFee(builder, feeOffset);
      return MosaicLevy.endMosaicLevy(builder);
    }
  }